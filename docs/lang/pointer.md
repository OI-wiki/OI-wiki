## 左值和右值

学习指针之前，我们需要先学习 **左值** （leftvalue）和 **右值** （rightvalue）的概念。在 C++ 中，能够出现在赋值运算符（ `=` ）左边的值就叫左值，只能出现在赋值运算符右边的值就叫右值[^note1]。

例如，有一个整型变量 `a` ，赋值语句 `a = 3` 是合法的，但是 `3 = a` 则是非法的，因为 `3` 是右值。而有时候左值不是一个单独的变量，是通过一系列运算得到的。例如数组 `a[2] = 3` ，这里的左值是 `a[2]` ，进行了一次运算。（严格来说是两次，下面会解释。）

一般来说，每一个左值都可以视为内存中一个确定的区域，可以对这个区域进行写入和读取。

## 指针的定义

### 基本概念

指针也是一种变量，与其他变量不同的是，指针存储的是一个内存空间的地址，该地址对应的变量“被这个指针指向”。

指针的大小在不同环境下有差异。在 32 位机上，地址用 32 位二进制整数表示，因此一个指针的大小为 4 字节。而 64 位机上，地址用 64 位二进制整数表示，因此一个指针的大小就变成了 8 字节。

![example](./images/pointer1.png)

当然，一个指针也可以指向指针。

![example2](./images/pointer2.png)

### 取址和解引用

每一个变量都有其地址。地址是内存区域的一个编号，通过这个编号可以访问到相应的内存区域。而我们在上面学习到每一个左值实质上就是一块内存区域，因此地址也可以视作左值的一个编号。

通过一个左值获取它的编号的操作就叫“取址”，取址运算符是 `&` 。而通过一个编号获取对应左值的操作叫“解引用”，解引用运算符是 `*` 。

例如，在下面的代码块中 `int *p;` 定义了一个指向 `int` 类型变量的指针 `p` 。

```cpp
int i = 3;
int *p = &i;   // 现在 p 是一个指针，指向 i
int **q = &p;  // q 是一个指针，指向指针 p
cout << p << " " << *p << endl;
cout << q << " " << *q << " " << **q;
```

运行上面这段代码，输出结果可能是：

```text
0x22fec8 3
0x22fec4 0x22fec8 3
```

在这次运行中， `0x22fec8` 就是变量 `i` 的地址， `0x22fec4` 就是指针 `*p` 的地址。每次运行，这两个值都可能会变更。

## 指针的应用

阅读本文需要预先学习 [函数](./func.md) 的基础知识。

指针一个经典应用就是 **交换两数的值** 。接下来将会给出几份用函数实现交换两数的值的代码。

一份错误的代码实现如下：

```cpp
void swap(int a, int b) {
  int t = a;
  a = b;
  b = t;
}

// main
int a = 1, b = 2;
swap(a, b);
cout << a << b;
```

输出

```text
1 2
```

可以发现 `a` 和 `b` 的值没有成功交换。因为 `swap` 函数的参数 `a` 和 `b` 与 `main` 函数中的 `a`  `b` 不同（虽然它们的名字相同）。交换 `swap` 函数中的 `a` 和 `b` ，并不会对 `main` 中的两个变量造成影响。

下面是一份正确的代码实现。

```cpp
void swap(int *a, int *b) {
  int t;
  t = *a;
  *a = *b;
  *b = t;
}

// main
int a = 1, b = 2;
swap(&a, &b);
cout << a << b;
```

上面这个程序为什么能实现交换两个变量的值呢？

原因在于， `swap` 函数中的的 `*a` 和 `*b` 指针分别指向了 `main` 函数中的 `a` 和 `b` 这两个变量。 `swap` 函数实质上交换了 `*a` 和 `*b` ，从而实现了交换两个变量的值的目的。

## 指针运算

指针除了取址和解引用之外，还有不少运算操作。以下假设 `p` 是指向 `int` 类型变量的指针， `x` 是一个整数。

### 指针加整数

指针加整数 `p+x` 的值即为一个新指针，该新指针的值为 `p` 右移 `x*sizeof(*p)` 字节的值。注意“右移”不是“右位移”，“右位移”是位运算的操作。 `sizeof(*p)` 取出 `*p` 类型对应的字节数。

数组占据一块连续的内存空间，因此若数组 `a[0]` 的编号是 `8` ，那么 `a[1]` 的编号就是 `12` ， `a[3]` 的编号就是 `20` （此处编号的单位为“字节”）。 `&(a[3]) == &(a[0])+3` 。

这里为什么是四个四个加呢？因为各类型占内存大小不同。指针编号的单位是字节，而 `int` 类型占四个字节。因为 `char` 类型正好占一个字节，所以如果需要指定位移的字节数，我们会将指针强制转换成 `char*` 类型。

### 指针减整数

指针减整数 `p-x` 的值和指针加整数类似，也是一个新指针，指向 `p` 左移 `x*sizeof(*p)` 字节的值。

例如，如果 `a` 是一个数组，那么 `&(a[0]) == &(a[3])-3` 。

### 指针减指针

指针减指针是一个很强大的操作。指针减指针得到的是一个偏移量，代表指针间相距元素的个数。偏移量可正可负。

举例， `&(a[3])-&(a[0]) == 3` ， `&(a[0])-&(a[3]) == -3` 。

实际类型是 `ptrdiff_t` ，包含在 `stddif.h` （C++ 中则为 `cstddif` ）中。

### 指针自增自减

指针自增自减的定义与算术中自增自减的定义相似，不详细展开。

### 指针类型转换

可以强制转换指针的类型。如果 `p` 是一个 `int*` 类型的指针，可以通过 `(long long*)p` 得到一个新指针，该指针指向的地址和 `p` 相同，类型由原来的 `int*` 强制转换成 `long long*` ，之后对其的解引用操作会获得一个 `long long` 类型的左值，各种运算也是以 `long long` 为基础类型。

虽然 `void` 类型不是一个合法的左值，但是存在 `void*` 类型的指针。在 ANSI C 标准中这种类型的指针无法解引用，也无法加减，在 GNU 标准中，这种类型的指针加减的单位是一个字节。C++ 中， `void*` 类型可以强制转换成任意类型，而指针转换成 `void*` 类型可以通过隐式转换，即将指针 `p` 当作 `void*` 使用的时候不需要写作 `(void*)p` 。

## 数组中的指针

前置知识： [数组](./array.md) 。

指针不仅可以应用在变量中，它还可以应用在数组中，请看如下代码。

### 用指针访问数组

```cpp
int a[5] = {1, 2, 3, 4, 5};
int *p;
for (p = a; p < a + 5; p++) {
  cout << *p << " ";
}
```

输出

```cpp
1 2 3 4 5
```

结合以上的介绍，应该不难理解。

### 数组与指针的关系

数组名可以视作一个指针，即如果 `a` 是一个 `int` 类型的数组，那么 `a` 等价于 `&(a[0])` ，注意数组名是右值。因此， `a[3]` 就等价于 `*(a+3)` ，实际上它就是这么定义的，因此可以认为 `a[3]` 经历两次运算，一次指针和整数的加法，一次解引用。因为 `a+3=3+a` ，所以 `3[a]` 也可以表示同一个左值。因此， `a[3]=5` 还可以这么写：

```cpp
3 [a] = 5;
```

### 应用

有时候一些字符串题从 1 开始读入字符串会更为方便，而如果用 `scanf` 读入字符串的话，实际上需要用一个字符数组。

例如以下代码：

```cpp
char str[100005];

// main
scanf("%s", str)
```

而这里的读入是从 0 开始读入的。那么如何从 1 开始读入呢？

```cpp
scanf("%s", str + 1);
```

同样，使用 `strlen(str+1)` 可以处理从 1 开始的字符串的长度。

另外，使用指针比存储元素在数组中的编号更快。因为访问数组需要多进行一次 `long long` 加法（在 64 位机上）。这个技巧在以后可能会有用。

## 结构体指针

### 应用

前置知识： [结构体](./struct.md) 。

既然有指向普通元素的指针，那么相对应的也应该有指向结构体的指针。

### 定义

结构体指针就是指向结构体类型变量的指针：

```cpp
struct node {
  int a;
  double b;
  long long c;
};

// main
node x;
node *p = &x;
```

这时候 `p` 就是一个结构体指针，其类型是 `node *` 。

### 访问

```cpp
// read2
int a = (*p).a;
double b = (*p).b;
(*p).b = 3.14;
printf("%lld\n", (*p).c);
```

当然，这种写法有点麻烦。我们可以使用 `->` 运算符。 `a->b` 等价于 `(*a).b` 

```cpp
// read
int a = p->a;
double b = p->b;
p->b = 3.14;
printf("%lld\n", p->c);
```

### 声明

声明及定义指针的时候并不要求其对应的类型是完整的的。也就是说，指针指向的类型可以是不完整类型。

什么意思呢？完整的类型就是已经定义完的类型，一般在结构体中出现的变量的类型都必须是完整的。例如，不能这么写：

```cpp
struct node {
  int x;
  node p;
};
```

但是，由于声明指针的时候不要求那个类型完整，所以可以这么干：

```cpp
struct node {
  int x;
  node* p;
};
```

这就是 [链表](../ds/linked-list.md) 的基础。

???+note: "具体哪些是不完整类型？"
    包含：+void 类型（可有 cv 限定，即 const 或 volatile 限定）；+ 已声明（例如由前置声明）但未定义的类类型；+ 未知边界数组；+ 不完整类型元素的数组；+ 枚举类型，从其声明点到确定其底层类型之间。
    一般在需要知道类型的大小和布局的时候要求类型完整。

## 申请/释放内存

指针声明后没有经过初始化，其指向的内存空间是无意义的。如果需要为其分配一定大小的内存空间，除利用取址符获取已有内存空间的地址外，还可以经过申请得到。

申请的内存需要释放，否则会造成内存泄露。

 [函数指针](#9) 不能动态申请。

### 申请

可以使用 `new` 关键字申请一块内存区域。

单个变量：

```cpp
int *w = new int;
node *a = new node;
```

数组：

```cpp
int *w = new int[500];
// 现在 w 是一个 int 数组了，长度为 500
w[2] = 3;
```

上面提到过，数组名可以视作一个指针，那么指针也可以视作一个数组名。

二维数组：

```cpp
int (*w)[100] = new int[100][100];
// 现在 w 是一个二维 int 数组了，长度为 100*100
```

这里需要注意， `int *w[100]` 所定义的是一个一维的指针数组，而 `int (*w)[100]` 定义的是一个指向一维数组的指针，这两个概念是不一样的。由于二维数组是“一维数组的一维数组”，因此二维数组名是“指向一维数组的指针”，所以必须使用 `int(*)[100]` 类型。

具体来说，假设我们定义 `int *w1[100]` ， `int (*w2)[100]` 以便于区分，那么 w1 就是一个长度为 100 的数组，这里面的每一个元素都是一个 `int *` 。而 `w2` 是一个指针，指向一个长度为 100 的数组。如果 `w2` 到 `w2+99` 都是一个与 `w2` 类型相同的指针，即如果他们都指向一个长度为 100 的数组，那么 `w2` 就可以作为一个长度为 `100*100` 的二维数组名来访问与读取。

图示如下：

（记得提醒作者他咕了）

 `new` 还可以在分配内存的同时进行初始化。例如，如果想要分配一个 100\*100 的二维 int 数组，都初始化成 0，可以这么写：

```cpp
int (*w)[100] =
    new int[100][100]{};  // 类似于在全局命名空间中定义数组时的初始化

int *arr = new int[6]{
    1, 2, 3, 4, 5, 6};  // 定义了一个长度为 6 的数组，元素依次为 1,2,3,4,5,6
```

### 释放

如果是使用 `new` 申请的，使用 `delete` 关键字释放。

单个变量：

```cpp
delete w;
delete a;
```

数组：

```cpp
delete[] w;
```

二维数组：

```cpp
delete[] w;
```

这里我们看到二维数组不是 `delete[][]` 。原因是，之前我们提到过二维数组的类型是“一维数组的一维数组”，那么它其实就是一个特殊的一维数组，这个一维数组里的每一个元素都是一维数组。因此，我们可以使用释放一维数组的 `delete[]` 来释放它。

## 常见错误

离奇的 RE 错误可能由指针引起，其中申请/释放部分是最容易出错的地方。

如果出现报错：

```text
double free or operation(core dumped)
```

说明一个指针被释放了两次或释放后又进行了解引用操作。

## 扩展：函数指针

前置知识： [函数](./func.md) 

函数指针就是指向函数的指针。

关于函数指针，需要知道 C++ 中函数调用的底层机制。在 C 及 C++ 中，函数调用需要知道函数的参数类型和个数，以及调用协议。明确这些之后，再知道函数入口地址，就可以顺利调用。而有很多函数参数类型和个数都相同，而入口地址不同。因此，可以将函数的入口地址存储下来，就可以动态选择要调用的函数。

函数指针的定义很简单，根据“解方程规则”，一个接收两个 `int` 类型参数、返回 `int` 类型的函数指针 `calc` 可以定义为 `int (*calc)(int,int)` ，意思是“ `(*calc)(int,int)` 的类型是 `int` ”。如果使用 `int *calc(int,int)` 的话，就会变成一个接收两个 `int` 返回 `int*` 的函数了。

函数指针的赋值是怎么赋值的呢？回想函数调用所需的信息，函数调用的话需要知道参数列表和入口地址，如果调用函数 `add(a,b)` 的话，参数列表就是 `(a,b)` ，那么入口地址自然就是 `add` 了。那么，既然函数指针存储的是入口地址，执行 `calc=add` 就相当于将函数 `add` 的入口地址赋值给了 `calc` 。

而调用就很有趣了。由于定义是 `int (*calc)(int,int)` ，因此可以使用 `(*calc)(1,2)` 的形式来调用函数。而从另外一个方面，因为我们赋值的时候有 `calc=add` ，那么既然可以直接用 `add(1,2)` ，也应该能直接用 `calc(1,2)` 。

借助函数指针，函数也可以返回函数或者传入函数了。例如，一个简单的计算器程序如下：

```cpp
#include <cstdio>

int add(int a, int b) { return a + b; }

int sub(int a, int b) { return a - b; }

int mul(int a, int b) { return a * b; }

int div(int a, int b) { return a / b; }

int err(int a, int b) {
  printf("ERROR!");
  return -1;
}

int (*(calc(char ch)))(int, int) {
  if (ch == '+') return add;
  if (ch == '-') return sub;
  if (ch == '*') return mul;
  if (ch == '/') return div;
  return err;
}

int main() {
  int a, b;
  char opt;
  std::scanf("%d%c%d", &a, &opt, &b);
  std::printf("%d", calc(opt)(a, b));

  // std::printf("%d",calc('+')(1,2));
  // 也可写作 std::printf("%d",(*(calc(opt)))(a,b));
}
```

实际上，这样的类型声明很恶心，容易出错。借助 `typedef` ，可以这样干：

```cpp
typedef int (*func)(int, int);

func calc(char) { ... }
```

需要注意，函数指针没有通常指针所具有的与整数的加减运算，同样也没有自增自减和相减运算。

## 参考资料与注释

[^note1]: 这里使用的是 C 中的定义，C++98 标准中继续沿用了该种划分方式。但在 C++11 标准中，值类型被重新定义，所有的值被分为左值，纯右值和亡值三类。更详细的内容可以参考 [值类别 - cppreference.com](https://zh.cppreference.com/w/cpp/language/value_category) 。
