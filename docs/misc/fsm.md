author: CCXXXI, countercurrent-time, Enter-tainer, FFjet, H-J-Granger, Ir1d, mgt, NachtgeistW, orzAtalod, ouuan, ouuan, SukkaW

有限状态自动机（Finite State Machine，FSM，以下也简称自动机）是最简单的一类计算模型，体现在它的描述能力与资源都极其有限。自动机在 OI、计算机科学中被广泛使用，其思想在许多字符串算法中都有涉及，因此推荐在学习一些字符串算法（[KMP](../string/kmp.md)、[AC 自动机](../string/ac-automaton.md)、[SAM](../string/sam.md)）前先完成自动机的学习。学习自动机有助于理解上述算法。

## 自动机入门

首先理解一下自动机是用来干什么的：自动机是一个对信号序列进行判定的数学模型。

这句话涉及到的名词比较多，逐一解释一下。「信号序列」是指一连串有顺序的信号，例如字符串从前到后的每一个字符、数组从 $1$ 到 $n$ 的每一个数、数从高到低的每一位等。「判定」是指针对某一个命题给出或真或假的回答。有时我们需要对一个信号序列进行判定。一个简单的例子就是判定一个二进制数是奇数还是偶数，较复杂的例子例如判定一个字符串是否回文，判定一个字符串是不是某个特定字符串的子序列等等。

自动机的工作原理和流程图很类似。假设你想要在外卖平台点购一杯奶茶，你的所有选择就构成了一个序列。以下这个流程图是一个例子：

![order fsm](./images/fsm1.svg)

例如，你的选择序列是「打开点单界面 -> 选择奶茶 -> 有奶茶的钱」，那你按顺序经过的路口可能是「外卖平台 -> 点单界面 -> 支付奶茶的钱 -> 买到奶茶」。最后我们发现，我们的这个「奶茶自动机」根据我们的选择，帮我们判定了我们是否买到了奶茶。

可以发现，到达一个状态的方法可能不止一条。同样没有买到奶茶，你可能是在点单界面直接退出，或者没有奶茶的钱以至于没有买到奶茶。

我们通过这个自动机，将信号序列分成了两类，一类是买到了奶茶的信号序列，一类是没有买到奶茶的信号序列，以此完成了一个判定问题。

既然自动机是一个数学模型，那么显然不可能是一张流程图。我们需要对其进行抽象。对流程图进行抽象之后，可以简化为一个有向图。因此，自动机的结构可以看作一张有向图，称作**状态图**。

而自动机的工作方式和流程图类似，不同的是：自动机的每一个结点都是一个判定结点；自动机的结点只是一个单纯的状态而非任务；自动机的边可以接受多种字符（不局限于 T 或 F）。

举个例子，完成「判断一个二进制数是不是偶数」的自动机如下：

![example fsm](./images/fsm2.png)

从起始结点开始，从高到低接受这个数的二进制序列，然后看最终停在哪里。如果最终停在红圈结点，则是偶数，否则不是。

在这里，我们需要强调，下文中我们会多次提到「字符」、「字符集」之类的名词，这不代表自动机只能应用于字符串领域，字符不一定是字符串中的字符，也可以是一种选择。

如果需要判定一个有限的信号序列和另外一个信号序列的关系（例如另一个信号序列是不是某个信号序列的子序列），那么常用的方法是针对那个有限的信号序列构建一个自动机。这个在学习 KMP 的时候会讲到。

需要注意的是，自动机只是一个 **数学模型**，而 **不是算法**，也 **不是数据结构**。实现同一个自动机的方法有很多种，可能会有不一样的时空复杂度。

接下来你可以选择继续进一步研究自动机，也可以去学习 [KMP](../string/kmp.md)、[AC 自动机](../string/ac-automaton.md) 或 [SAM](../string/sam.md)。

FSM 分为两类：确定性有限状态自动机、不确定性有限状态自动机。

## 确定性有限状态自动机

确定性有限状态自动机（Deterministic Finite Automaton，DFA）体现在它的过程是确定性的，以「奶茶自动机」为例子，你只要打开点单界面，就会进入点单界面，不会出现网络崩溃打不开、手机没电黑屏了之类的意外情况。

形式化地定义 DFA：DFA 是一个五元组 $(Q,\Sigma,\delta,q_0,F)$，其中：

1.  **有限状态集合**（$Q$）。如果把一个 DFA 看成一张有向图，那么 DFA 中的状态就相当于图上的顶点。
2.  **字符集**（$\Sigma$），该自动机只能输入这些字符。
3.  **转移函数**（$\delta:Q\times \Sigma \to Q$），$\delta$ 是一个接受两个参数返回一个值的函数，其中第一个参数和返回值都是一个状态，第二个参数是字符集中的一个字符。如果把一个 DFA 看成一张有向图，那么 DFA 中的转移函数就相当于顶点间的边，而每条边上都有一个字符。
4.  **起始状态**（$q_0\in Q$），是一个特殊的状态。在文章中，起始状态一般用 $s$、$start$、$q_0$ 表示，本文中选择使用 $q_0$ 表示。
5.  **接受状态集合**（$F\subseteq Q$），是一组特殊的状态。

形式化地定义 DFA 的工作流程：

设 $M=(Q,\Sigma,\delta,q_0,F)$ 是一个 DFA，$w=w_1,w_2,\cdots,w_n(w_i\in \Sigma)$（也记作 $w\in\Sigma^*$）是一个串。若存在 $Q$ 中的状态序列 $r_0,r_1,\cdots,r_n$ 满足：

1. $r_0=q_0$。
2. $\delta(r_i,w_{i+1})=r_{i+1}$（$i\in\{0,1,\cdots,n-1\}$）。
3. $r_n\in F$。

则称 $M$ **接受** $w$。反之，则称 $M$ **不接受** $w$。

定义**形式语言**（简称 **语言**）是任意 $\Sigma$ 上串的集合（集合大小可以为无限），令语言 $L(M)=\{w|M\text{ 接受 }w\}$，则称 $M$ 识别 $L(M)$。

如果一个语言能被某个 DFA 识别，则称它为正则语言（Regular Language）。

当一个 DFA 读入一个字符串时，从初始状态起按照转移函数一个一个字符地转移。如果读入完一个字符串的所有字符后位于一个接受状态，那么我们称这个 DFA **接受** 这个字符串，反之我们称这个 DFA **不接受** 这个字符串。

为了方便说明，我们将求出输入串 $w$ 在 DFA 中的状态序列，并判断其是否被接受的过程称为**计算**。

上文提到过，一个自动机可以由状态图表示出来。如下是一个接受且仅接受字符串 $\tt a$、$\tt ab$、$\tt aac$ 的 DFA：

![](./images/fsm3.png)

## 不确定性有限状态自动机

非确定性有限状态自动机（Nondeterministic Finite Automaton，NFA）是 DFA 的自然推广，在非确定性机中，任何一个点和某个转移字符可能存在多个后继，同时，也有空字符的存在。

举个例子，还是「奶茶自动机」。下单后，有可能因为网络不佳从而没有买到奶茶，这是存在多个后继；也有可能因为手速慢了，尽管过程是一样的，却因为奶茶售完从而没有买到奶茶，这是空字符的存在，空字符可走可不走。

下面我们令 $\mathcal{P}(Q)$ 表示 $Q$ 的幂集（所有子集的集合），令 $\Sigma_{\epsilon}=\Sigma\cup\{\epsilon\}$（$\epsilon$ 表示空串，即允许空串的存在，空串可以走或者不走）。下面给出 NFA 的形式化定义：NFA 是一个五元组 $(Q,\Sigma,\delta,q_0,F)$，其中：

1.  **有限状态集合**（$Q$）。
2.  **字符集**（$\Sigma$）。
3.  **转移函数**（$\delta:Q\times \Sigma_{\epsilon} \to \mathcal{P}(Q)$）。
4.  **起始状态**（$q_0\in Q$）。
5.  **接受状态集合**（$F\subseteq Q$）。

同样形式化地定义 NFA 的工作流程，注意这里只要状态集合中存在一个状态属于接受状态集合，整个串就是被接受的：

设 $N=(Q,\Sigma,\delta,q_0,F)$ 是一个 NFA，$w$ 可以被表示为 $y_1,y_2,\cdots,y_m(y_i\in \Sigma_{\epsilon})$（举个例子，因为允许空串的存在，字符串 $\tt abc$ 也可以看作 $\tt {a}\epsilon\tt {bc}\epsilon\epsilon$）。若存在 $Q$ 中的状态序列 $r_0,r_1,\cdots,r_m$ 满足：

1. $r_0=q_0$。
2. $r_{i+1}\in\delta(r_i,y_{i+1})$（$i\in\{0,1,\cdots,m-1\}$）。
3. $r_m\in F$。

则称 $N$ **接受** $w$。反之，则称 $N$ **不接受** $w$。

DFA 与 NFA 的区别在于：DFA 的每一次输入只对应一个结果，而 NFA 的依次输入可能对应多个结果，形成一个结果集。接下来我们将介绍如何将 NFA 变为 DFA。

## DFA 与 NFA 的等价性

我们称两个自动机等价，当且仅当它们能识别的语言类相同。

DFA 与 NFA 是等价的，即每一个 NFA 都等价于某一个 DFA。

我们可以通过幂集构造（Powerset construction）的方法进行转换。

## DFA 与 NFA 的时间复杂度

设给定的串长为 $n$，自动机状态数为 $s$，字符集大小为常数。

那么显然的，DFA 计算的时间复杂度为 $O(n)$，只需要模拟上述的过程即可。

而朴素计算 NFA 的时间复杂度为 $O(ns^2)$，这是因为需要考虑到每一种后继，以及状态的合并所需的复杂度。

当然，可以使用 bitset 或者 Method of Four Russians 将计算的复杂度优化到 $O(\frac{ns^2}{w})$ 或 $O(\frac{ns^2}{w\cdot \log n})$。

## OI 中常用的自动机

### 字典树

[字典树](./trie.md) 是大部分 OIer 接触到的第一个自动机，接受且仅接受指定的字符串集合中的元素。

转移函数就是 Trie 上的边，接受状态是将每个字符串插入到 Trie 时到达的那个状态。

### KMP 自动机

[KMP 算法](./kmp.md) 可以视作自动机，基于字符串 $s$ 的 KMP 自动机接受且仅接受以 $s$ 为后缀的字符串，其接受状态为 $|s|$。

转移函数：

$$
\delta(i, c)=
\begin{cases}
i+1&s[i+1]=c\\
0&s[1]\ne c\land i=0\\
\delta(\pi(i),c)&s[i+1]\ne c\land i>0
\end{cases}
$$

### AC 自动机

[AC 自动机](./ac-automaton.md) 接受且仅接受以指定的字符串集合中的某个元素为后缀的字符串。也就是 Trie + KMP。

### 后缀自动机

[后缀自动机](./sam.md) 接受且仅接受指定字符串的后缀。

### 广义后缀自动机

[广义后缀自动机](./general-sam.md) 接受且仅接受指定的字符串集合中的某个元素的后缀。也就是 Trie + SAM。

广义 SAM 与 SAM 的关系就是 AC 自动机与 KMP 自动机的关系。

### 回文自动机

[回文自动机](./pam.md) 比较特殊，它不能非常方便地定义为自动机。

如果需要定义的话，它接受且仅接受某个字符串的所有回文子串的 **中心及右半部分**。

「中心及右边部分」在奇回文串中就是字面意思，在偶回文串中定义为一个特殊字符加上右边部分。这个定义看起来很奇怪，但它能让 PAM 真正成为一个自动机，而不仅是两棵树。

### 序列自动机

[序列自动机](./seq-automaton.md) 接受且仅接受指定字符串的子序列。

## 后缀链接

由于自动机和匹配有着密不可分的关系，而匹配的一个基本思想是「这个串不行，就试试它的后缀可不可以」，所以在很多自动机（KMP、AC 自动机、SAM、PAM）中，都有后缀链接的概念。

一个状态会对应若干字符串，而这个状态的后缀链接，是在自动机上的、是这些字符串的公共真后缀的字符串中，最长的那一个。

一般来讲，后缀链接会形成一棵树，并且不同自动机的后缀链接树有着一些相同的性质，学习时可以加以注意。

## 扩展阅读

在计算复杂性领域中，自动机是一个经典的模型。并且，自动机与正则语言有着密不可分的关系。

如果对相关内容感兴趣的话，推荐阅读博客 [计算复杂性（1）Warming Up: 自动机模型](https://lingeros-tot.github.io/2019/03/05/Warming-Up-自动机模型/)。
