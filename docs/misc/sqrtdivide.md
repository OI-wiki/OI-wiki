根号分治是一种特别的分治思想：它是以 $\sqrt N$ 为界分解问题的。

根号分治，是暴力美学的集大成体现。与其说是一种算法，不如称它为一个常用的 trick。

## 例题

下面引入一些题目介绍该思想：

### 例题 1

???+ note "[CF1207F Remainder Problem](https://www.luogu.com.cn/problem/CF1207F)"
    给定一个长度为 $n = 5 \times 10^5$ 的序列，初值为 $0$。要完成 $q \le 5 \times 10^5$ 次操作，操作有如下两种：
    
    1.  `1 x y`：将下标为 $x$ 的位置的值加上 $y$；
    2.  `2 x y`：询问所有下标模 $x$ 的结果为 $y$ 的位置的值之和，即计算：
    
    $$
    f(x, y) = \sum_{k \equiv y \pmod{x}} a_k
    $$

考虑这题的暴力是什么。

暴力 I：直接按照题目所说的去做，开一个长度为 $n$ 的数组 $a$ 去存，操作 1 就对 $a_x$ 加上 $y$，操作 2 就枚举所有满足 $k \equiv y \pmod{x}$ 的下标 $k$，计算 $a_k$ 的和。

对于这种暴力，操作 1 的时间复杂度为 $O(1)$，操作 2 的时间复杂度为 $O(n)$，所以在最坏情况下总时间复杂度可达 $O(nq)$。

暴力 II：开一个大小为 $n \times n$ 的二维数组 $b$，其中 $b_{x,y}$ 记录当前的 $f(x,y)$。此时对于操作 1，枚举所有的模数 $m$，将 $b_{m,x \bmod m}$ 加上 $y$ 即可；对于操作 2，直接输出 $b_{x,y}$ 即可。

对于这种暴力，操作 1 的时间复杂度为枚举模数的 $O(n)$，操作 2 的时间复杂度为 $O(1)$，所以在最坏情况下总时间复杂度可达 $O(nq)$。

上述两种暴力对应了两种极端：

-   暴力 I：操作 1 的时间复杂度为 $O(1)$，操作 2 的时间复杂度为 $O(n)$；
-   暴力 II：操作 1 的时间复杂度为 $O(n)$，操作 2 的时间复杂度为 $O(1)$。

那么，有没有办法让这两种暴力融合一下，均摊时间复杂度，达到一个平衡呢？

有，可以使用根号分治将两种暴力法结合起来。首先设定一个阈值 $B$。

对于操作 1，使用暴力 I 的同时：

-   若 $x \le B$，则维护暴力 II 的 $b$ 数组。此时每次操作 1 只需要枚举前 $B$ 个模数即可，故单次操作 1 的时间复杂度降为 $O(B)$；
-   若 $x > B$，则不维护暴力 II 的 $b$ 数组。

对于操作 2：

-   若 $x \le B$，使用暴力 II 的 $b$ 数组直接输出即可；
-   若 $x > B$，使用暴力 I。由于所有满足 $k \equiv y \pmod{x}$ 的下标 $k$ 必定是 $y + rx$ 的形式（其中 $r \in \mathbf Z$），因此最多有 $\lceil n / B\rceil$ 种取值，故单次操作 2 的时间复杂度降为 $O(n / B)$。

综上总时间复杂度变为了 $O(q(B + n / B))$，取 $B = \sqrt n$ 可以使 $B + n / B$ 达到最小值 $2\sqrt n$，此时总时间复杂度为 $O(q\sqrt n)$，空间复杂度 $O(n)$，可以通过此题。

??? "参考代码"
    ```cpp
    #include <bits/stdc++.h>
    #define ll long long
    #define mp make_pair
    using namespace std;
    ll sum[755][755], a[500005];  // 这里我的阈值取了700
    
    int main() {
      ios_base::sync_with_stdio(false);
      cin.tie(0), cout.tie(0);
      int q;
      cin >> q;
      for (; q--;) {
        int tp, x, y;
        cin >> tp >> x >> y;
        if (tp == 1) {
          for (int i = 1; i < 700; ++i) sum[i][x % i] += y;  // 枚举模数
          a[x] += y;
        } else {
          if (x < 700) {
            cout << sum[x][y] << endl;
          } else {
            ll rt = 0;
            for (int i = y; i <= 500000; i += x) rt += a[i];  // 暴力统计
            cout << rt << endl;
          }
        }
      }
    }
    ```

通过一道例题可以发现：根号分治不就是两个暴力揉到一起嘛！对于小于一个阈值的数据采取一种暴力形式，对于大于阈值的数据采用另外一种形式。通常，这两种暴力，一种是直接模拟，另外一种是动态的维护什么东西，或者预处理。暴力与暴力的完美结合，就能过题，有时候甚至可以爆踩标算。

### 例题 2

???+ note "[P1494 \[国家集训队\] 小 Z 的袜子](https://www.luogu.com.cn/problem/P1494)"
    给定一个长度为 $N \le 5 \times 10^4$ 的序列 $\langle C_i \rangle$ 表示袜子的颜色，$M \le 5 \times 10^4$ 次询问区间 $[L, R]$ 内有多大概率抽到两只颜色相同的袜子。

由古典概率可知每次询问的答案即为：

$$
\frac{\sum_{L \le i < j \le R}[C_i = C_j]}{\binom{R + 1 - L}{2}}
$$

问题转化为计算区间内相同无序点对的数量。为人熟知的做法是使用普通莫队算法，但此题也可以用根号分治在相同的复杂度内完成。对于每种颜色 $c$，考虑其出现的次数 $t_c$：

1.  $t_c \ge \sqrt N$：这样的颜色最多只有 $\lfloor\sqrt N\rfloor$ 种。

预处理出每种颜色 $c$ 出现次数的前缀和，询问时暴力枚举每种颜色 $c$ 的出现次数 $t_c$ 后将答案累加上 $\dbinom{t_c}{2}$ 即可。

时间复杂度：预处理 $O(N\sqrt N)$，单次询问 $O(\sqrt N)$，所有询问 $O(M\sqrt N)$，合计 $O((N + M)\sqrt N)$。

2.  $t_c < \sqrt N$：这样的颜色总计能产生的相同点对数量不超过 $O(N\sqrt N)$ 的数量级。

建立一个数组 $\langle b_j \rangle$，表示当前对于每个位置 $j$，有 $b_j$ 个颜色相同的在其之后。再对于每种颜色用列表记录其出现过的下标。

对于所有询问按其右端点 $R$ 升序排序。顺序枚举 $i \in [1, n]$，遇到第 2 类颜色就更新一次数组 $\langle b_j \rangle$，更新时使用记录过的下标来降低复杂度，之后更新记录过的下标。当 $i = R$ 时，区间 $[L, R]$ 内的 $\sum b_j$ 即为该区间内第 2 类相同颜色的点对数，将其累加进答案然后处理下一询问。

时间复杂度：预处理为排序的时间复杂度，$O(N\sqrt N)$ 次单点自增，$O(M)$ 次区间求和，而块状数组的单点自增复杂度为 $O(1)$，区间求和复杂度为 $O(\sqrt N)$，因此合计 $O((N + M)\sqrt N)$。

将上述两种做法的结果直接相加即可得到答案，总时间复杂度 $O((N + M)\sqrt N)$。

## 参考资料

-   [暴力美学——浅谈根号分治](https://www.luogu.com.cn/blog/Amateur-threshold/pu-li-mei-xue-qian-tan-gen-hao-fen-zhi#)
