算法竞赛的树和现实生活中的树长得一样，只不过我们习惯于处理问题的时候把树根放到上方来考虑。

这种数据结构看起来像是一个倒挂的树，因此得名。

形式化的定义：

-   有 $n$ 个节点， $n-1$ 条边的连通无向图，
-   无向无环连通图
-   任意两个节点之间有且仅有一条简单路径的无向图

## 有关树的定义s

### 森林

每个连通分量（连通块）都是树的图

### 生成树

一个图的生成子图，同时要求是树。

### 有根树

指定了一个点是根的树

### 无根树

没有指定一个根节点的树

### 深度

#### 节点的深度

到根节点的距离（最短路径的长度）

#### 树的深度

所有节点的深度的最大值

### 父亲

一个节点到根节点的路径上的第二个节点

### 祖先

一个节点到根节点的路径上，除了它本身外的所有节点

### 子节点

如果 u 是 v 的父亲，那么 v 是 u 的子节点。

### 兄弟

同一个父亲的多个子节点互为兄弟

### 后代（子孙）

子节点和子节点的后代

或者理解成：如果 u 是 v 的祖先，那么 v 是 u 的后代。

### 度数

#### 无根树

和一个点相关的边的个数

#### 有根树

子节点个数

### 叶节点

#### 无根树

度数不超过 1 的节点

??? question "为什么不是度为 1？"
    考虑 $n = 1$ 的时候。

#### 有根树

没有子节点（度数为 0）的节点

### 子树

删掉与父亲相连的边后，该节点所在的子图

## 特殊的树

### 只有一个节点

没有边

$n = 1, m = 0$

### 链

点 $i$ 的父亲为 $i - 1$。

树的深度为$n - i$。

### 菊花

所有非根节点的父亲均为根节点。

输的深度为 1.

### 二叉树

每个节点最多只有两个儿子（子节点）的树

#### 满二叉树

#### 完全二叉树

这里好像需要有图。（图待补）

## 如何存树

### 存父亲

用一个数组记录每个节点的父亲节点：`fa`数组

### 邻接表

当成图来存

有根树：`vector<int> childs[n], fa[n]`

二叉树：`int lch[n], rch[n], fa[n]`
