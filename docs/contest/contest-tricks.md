author: jiangmuran

本页面旨在告诉你如何在遇到不会/写不出来算法的情况下，如何在比赛中合规的拿到尽可能多的分数。

???+warning "注意"

    本页面不适用于训练/刷题，通常适用于OI赛制的比赛现场。本内容部分

## 特殊情况

### 无解

在很多题目中都有这句话：「若无解，请输出 `-1`. 」

那么，只要打出下面这个程序： `printf("-1");` 就能得到部分分数。

举个例子： [P1078 [NOIP2012 普及组] 文化之旅](https://www.luogu.com.cn/problem/P1078)

这道题看起来很复杂，但是如果你打出 `printf("-1");`，可以得到 10 分。

### 样例

每道题目的后面，都有一组 「样例输入」和 「样例输出」 。它们的价值极大，不仅能初步帮你检验程序的对错

而且，如果你不会做这道题，你就可以直接输出样例。

 例如美国的 USACO，它的题目有一个规则，就是第一组数据必须是样例。那么，只要你输出所有的样例，你就能得到 100 分（满分 1000 分），这是相当可观的分数了。

???+warning "注意"

    目前大部分比赛此方法不适用

## 朴素算法

### 模拟

所谓模拟，就是用计算机程序来模拟实际的事件。例如 [P1076 [NOIP2012 普及组] 寻宝](https://www.luogu.com.cn/problem/P1076)，就是写一个程序来模拟小明上藏宝塔的动作。

较繁的模拟就不叫骗分了，我这里也不讨论这个问题。

模拟主要可以应用在骗高级数据结构题上的分，例如线段树。下面举一个例子来说明一下。

[P2880 [USACO07JAN] Balanced Lineup G](https://www.luogu.com.cn/problem/P2880)

对于这个例子，通过简单的模拟可以得到部分分。

=== "c++"

```c++
  for(int i=1;i<=q;i++)
  {
    scanf("%d%d",&a,&b);
    int min=INT_MAX,max=INT_MIN;
    for(int i=a;i<=b;i++)
    {
      if(h[i]<min)min=h[i];
      if(h[i]>max)max=h[i];
    }
    printf("%d\n",max-min);
  }
```

本程序得$50$分

### DFS

DFS 是图论中的重要算法，但我们看来，图论都是浮云，关键就是如何骗分。下面引出本页面的第 2 条定理：DFS 是万能的。

这对于你的骗分是至关重要的。比如说，一些动态规划题，可以 DFS；数学题，可以 DFS；剪枝的题，更能 DFS。下面以一道省选题为例，解释一下 DFS 骗分。

例题： [P1048 [NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)

这题的方法很简单。我们瞄准 20 的数据来做，可以用 DFS 枚举方案，然后模拟计算出最优解。

附一个大致的代码：

=== "c++"

```c++
void DFS(int d,int c){
if(d==n){
    if(c>ans)ans=c;
    return;
}
DFS(d+1,c+w[i]);
DFS(d+1,c);
}
```

## 猜想

### 随机数

如果你觉得你的人品很好，可以试试输出随机数。

=== "c"

```c
#include<cstdlib>
#include<ctime>
#include<cstdio>
//<ctime>和<cstdlib>必不可少 
using namespace std;

int random(int start,int end)    //随机数函数 
{
    end++;
    int res=start+(end-start)*rand()/(RAND_MAX + 1.0);
    return res;
}
int main()
{
    srand(unsigned(time(0)));    //利用时间确定随机数种子 
    for(int i=1;i<=1000;i++)
        printf("%d\n",random(1,100));    //重复一千次输出 1~100 之间的任意数 
    return 0;
}
```

???+warning "警告"

    本方法在绝大多数情况下无法得分，且部分比赛禁止使用随机数。通常不会使用此方法 

### 猜测答案

有些时候，问题的答案可能很有特点：对于大多数情况，答案是一样的。这时，骗分就该出手了。你需要做的，就是发掘出这个答案，然后直接输出。

有时，你需要运用第 3 章中学到的知识，先写出朴素算法，然后造一些数据，可能就会发现规律。

例如[P8819 [CSP-S 2022] 星战](https://www.luogu.com.cn/problem/P8819)：

只要读完题就可以发现，这道题 `NO` 的概率特别高，所以可以尝试对于每一个问题都输出 `NO`，可得 45 分，对于 T3 已经是很高的得分了（尤其是在有多组数据的情况下）。

OIer 们对此表示了强烈不满，详见：[不可以，总司令](https://www.luogu.com.cn/discuss/525529) 

### 寻找规律

首先声明：本节讲的规律不是正当的算法规律，而是数据的特点。

某些题目会给你很多样例，你就可以观察他们的特点了。有时，数据中的某一个（或几个）数，能通过简单的关系直接算出答案。

只要你找到了规律，在很多情况下你都能得到可观的分数。

### 打表

顾名思义，就是将可能的输出做成一个表格。

例子：[NOIP2003 栈](https://www.luogu.com.cn/problem/P1044)

这题看似复杂，但数据范围太小，N≤18。所以，骗分程序就好写了：

=== "c"

```c
int a[18]={1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700}; 
scanf("%d",&n);
printf("%d",ans[n-1]);
```

本题得$100$分

## 贪心

### 贪心的算法

给你一堆纸币，让你挑一张，相信你一定会挑面值最大的。其实，这就是贪心算法。

贪心算法是个复杂的问题，但你不用管那么多。我们只关心骗分。给你一个问题，让你从一些东西中选出一些，你就可以使用贪心的方法，尽量挑好的。

举个例子：

[U480191 【新版骗分导论 - 修订版】有趣的问题](https://www.luogu.com.cn/problem/U480191)

这题让人望而生畏，但我们有贪心的手段。每个二元组的 a 值是乘到答案中的，所以 a 越大越好，那么只要选择出最小的 k 个去掉即可。代码就不写了，因为这个涉及到下一章的内容：排序。

此代码得 20 分。 

### 贪心的得分

我们已经学了很多骗分方法，但他们中的大多效率并不高，一般能骗 10∼20 分。这不能满足我们的贪心。

然而，我们可以合成骗分的程序。举个最简单的例子，有些含有无解情况的题目，

它们同样有样例。我们可以写这个程序

```cpp
if(是样例) printf(样例);else printf("-1");
```

这样也许能变 10 分为 20 分，甚至更多。

当然，合并方法时要注意，不要重复输出同一种情况，或漏考虑一些情况。

## STL

这部分在其他章节已经讲的很清楚了，请参考[STL算法](../lang/csl/algorithm.md) 

## 骗分实战

以NOIP 2013普及组举例：   

1. [P1980 [NOIP2013 普及组] 计数问题](https://www.luogu.com.cn/problem/P1980)

2. [P1981 [NOIP2013 普及组] 表达式求值](https://www.luogu.com.cn/problem/P1981)

3. [[NOIP2013 普及组] 小朋友的数字](https://www.luogu.com.cn/problem/P1982)

4. [[NOIP2013 普及组] 车站分级](https://www.luogu.com.cn/problem/P1983)
- 第 1 题，正解，得 100 分。

- 第 2 题，数据很大，但是可以直接输入一个数，输出它 mod10000 的值。得 10 分。

- 第 3 题，是一道非常基础的 DP，使用暴力算法（即 DFS）。得 20 分。

- 第 4 题，我们可以寻找一下数据的规律，你会发现，在所有样例中， M 值即为答案。所以直接输出 M ，得 10 分。 

## 参考资料与注释

1. 《骗分导论》[李博杰](https://baike.baidu.com/item/%E6%9D%8E%E5%8D%9A%E6%9D%B0/64250966) 著

2. 《新版骗分导论》 CYD 著
