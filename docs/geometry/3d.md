author: shuzhouliu

## 前置技能

以下内容需要二维计算几何基础、向量、向量积以及空间直角坐标系相关知识，请先熟悉 [向量](../math/vector.md) 和 [二维计算几何基础](./2d.md) 页面的相关内容。

## 图形的记录

### 点

在空间直角坐标系下，点用坐标表示，比如点 $(2,7,23)$ 等。

我们可以记录其在 $x$ 轴，$y$ 轴和 $z$ 轴的坐标值，用结构体表示即可。

### 向量

三维向量的表示与二维向量一样，可以用坐标表示。

???+ note "如何用坐标表示"
    使用两个点的坐标就可以计算向量，假设有两点 $P_1$ 和 $P_2$，以 $P_1$ 作为基准点，向量 $V = P_2-P_1$，假如以 $P_2$ 作为基准点，则向量 $V = P_1-P_2$，总之 $V = P-P_b$，$P_b$ 为基准点。$V = P-P_b = (x-x_b, y-y_b, z-z_b) = (a, b, c)
    举例：假设$ P_1 = (1, 2, 3)$，$ P_2 = (2, 2, 2)$，将P_2看作基准点，那么根据公式：$ V = P_1-P_2= (-1, 0, 1) $.[^3d-basics-1]

向量的模：$|V| = \sqrt{a^2+b^2+c^2}$

向量的点乘：若有两个向量 $a=(x_1,y_1,z_1)$，$b=(x_2,y_2,z_2)$，则 $a·b = (x_1x_2 + y_1y_2 + z_1z_2)$。

#### 三维向量的叉乘

> 好耶，我们竟然定义了这么神奇的运算！

两个向量 $a=(x_1,y_1,z_1)$，$b=(x_2,y_2,z_2)$ 叉积的结果是一个向量 $c$。记作 $c = a \times b$。
我们可以简单的运用行列式表示：

$$
\left |\begin{array}{cccc}
u_x & u_y   & u_z \\
x_1 & y_1 & z_1  \\
x_2 & y_2 & z_2 \\
\end{array}\right |
$$

其中 $u_x, u_y, u_z$ 表示单位向量合并，并写在对应坐标处。
展开得 $c = (y_1-z_2,x_2z_1-x_1z_2,x_1y_2-x_2y_1)$。

### 极坐标

三维的极坐标可表示为两种：圆柱坐标和球面坐标。

圆柱坐标将极坐标扩展为三维的方式：从应用于平面工作中的二维系统开始，然后添加垂直于该平面的第三轴。

假如将第三轴称为 $z$ 轴，为了找到由圆柱坐标 $(r, θ, z)$ 所描述的点，可以首先处理 $r$ 和 $θ$，然后根据 $z$ 坐标“向上”或“向下”移动。

球面坐标可以以以下方法确定：

首先站在原点，面向水平极轴的方向。垂直轴的指向是从脚指向头部。右臂向上，指向垂直极轴方向；逆时针旋转角度 $\theta$；将手臂向下旋转角度 $\phi$，手臂指向极角 $\theta$ 和 $\phi$ 指定的方向；沿着该方向从原点移位距离 $r$。到达球面坐标 $(r,\theta,\phi)$ 所描述的点。

### 直线与射线

同样的，直线和射线可以用向量来表示。

我们考虑一下如何进行空间直线的存储。不难想到一般式、对称式（点向式）和参数方程，但是有点繁琐。

所以我们可以按照 [二维计算几何基础](./2d.md) 中提到的方法也用方向向量表示，即有一个方向向量 $s=(m, n, p)$。于是我们就得到了表示法。

#### 一些命题

- 两直线的方向向量的夹角，叫做两直线的夹角。

有了这个命题，我们就可以得出以下结论：已知两条直线 $l_1, l_2$，它们的方向向量分别是 $s_1 (m_1, n_1, p_1)$，$s_2 (m_2, n_2, p_2)$，设 $\phi$ 为两直线夹角，我们可以得到 $\cos \phi = \dfrac{\left | m_1m_2+n_1n_2+p_1p_2 \right |}{\sqrt{m_1^2+n_1^2+p_1^2}\sqrt{m_2^2+n_2^2+p_2^2}}$.

- $l_1 \perp l_2 \iff m_1m_2 + n_1n_2 + p_1p_2 = 0$

- $l_1 \parallel l_2 \iff \frac{m_1}{m_2} = \frac{n_1}{n_2} = \frac{p_1}{p_2}$.

#### 三维向量与平面的夹角

> 当直线与平面不垂直时，直线和它在平面上的投影直线的夹角 $\phi$（$\phi \in \[0, \frac{\pi}{2}\]$）称为直线与平面的夹角。
> ——同济大学《高等数学（下）》

设直线向量 $s(m, n, p)$，平面法线向量 $f(a, b, c)$，那么以下命题成立：

- 角度的正弦值：$\sin\phi = \dfrac{\left | am + bn + cp \right |}{\sqrt{a^2+b^2+c^2}\sqrt{m^2+n^2+p^2}}$

- 直线与平面平行 $\iff am+bn+cp = 0$

- 直线与平面垂直 $\iff \frac{a}{m} = \frac{b}{n} = \frac{c}{p}$

### 线段

节俭是美德，所以记一下两个点即可。

## 立体几何定理

### 三正弦定理（折叠角公式）

（高中教材人教版《数学》必修第二册（下 A））

设二面角 $M－AB－N$ 的度数为 $\alpha$，在平面 $M$ 上有一条射线 $AC$，它和棱 $AB$ 所成角为 $\beta$，和平面 $N$ 所成的角为 $\gamma$，则 $\sin\gamma = \sin\alpha·\sin\beta$。

### 三余弦定理（折叠角公式）

设 $O$ 为平面上一点，过平面外一点 $B$ 的直线 $BO$ 在面上的射影为 $AO$，$OC$ 为面上的一条直线，那么 $\angle COB，\angle AOC，\angle AOB$ 三角的余弦关系为：$\cos\angle BOC=\cos\angle AOB·\cos\angle AOC$（$\angle AOC$，$\angle AOB$ 只能是锐角）

## 三维凸包

### 基础知识

> 圆的反演：反演中心为 $O$，反演半径为 $R$，若经过 $O$ 的直线经过 $P$,$P′$，且 $OP∗OP′=R_2$，则称 $P$、$P′$ 关于 $O$ 互为反演。

求凸包：

1. 首先对其微小扰动，避免出现四点共面的情况。
2. 对于一个已知凸包，新增一个点 $P$，将 $P$ 视作一个点光源，向凸包做射线，可以知道，光线的可见面和不可见面一定是由若干条棱隔开的。
3.  将光的可见面删去，并新增由其分割棱与 P 构成的平面。
    重复此过程即可，由 [Pick 定理](./pick.md)、欧拉公式（$V−E+F=2$）和圆的反演，复杂度 $O(n^2)$。

### 例题

[P4724【模板】三维凸包](https://www.luogu.com.cn/problem/P4724) 重复上述过程即可得到答案。
???+ note "参考代码"

    ```cpp
        #include <iostream>
        #include <cstdio>
        #include <cstdlib>
        #include <cmath>
        using namespace std;
        const int N = 2010;
        const double eps = 1e-9;
        int n, cnt, vis[N][N];
        double ans;
        double Rand() {
            return rand() / (double)RAND_MAX;
        }
        double reps() {
            return (Rand() - 0.5) * eps;
        }
        struct Node {
            double x, y, z;
            void shake() {
                x += reps();
                y += reps();
                z += reps();
            }
            double len() {
                return sqrt(x * x + y * y + z * z);
            }
            Node operator - (Node A) {
                return { x - A.x, y - A.y, z - A.z };
            }
            Node operator * (Node A) {
                return { y *A.z - z *A.y, z *A.x - x *A.z, x *A.y - y *A.x };
            }
            double operator & (Node A) {
                return x * A.x + y * A.y + z * A.z;
            }
        } A[N];
        struct Face {
            int v[3];
            Node Normal() {
                return (A[v[1]] - A[v[0]]) * (A[v[2]] - A[v[0]]);
            }
            double area() {
                return Normal().len() / 2.0;
            }
        } f[N], C[N];
        int see(Face a, Node b) {
            return ((b - A[a.v[0]])&a.Normal()) > 0;
        }
        void Convex_3D() {
            f[++cnt] = {1, 2, 3};
            f[++cnt] = {3, 2, 1};
        
            for (int i = 4, cc = 0; i <= n; i++) {
                for (int j = 1, v; j <= cnt; j++) {
                    if (!(v = see(f[j], A[i])))
                        C[++cc] = f[j];
                for (int k = 0; k < 3; k++)
                    vis[f[j].v[k]][f[j].v[(k + 1) % 3]] = v;
            }

            for (int j = 1; j <= cnt; j++)
                for (int k = 0; k < 3; k++) {
                    int x = f[j].v[k], y = f[j].v[(k + 1) % 3];

                    if (vis[x][y] && !vis[y][x])
                        C[++cc] = {x, y, i};
            }

            for (int j = 1; j <= cc; j++)
                f[j] = C[j];

            cnt = cc;
            cc = 0;
            }
        }
        int main() {
            cin >> n;

            for (int i = 1; i <= n; i++)
                cin >> A[i].x >> A[i].y >> A[i].z, A[i].shake();

            Convex_3D();

            for (int i = 1; i <= cnt; i++)
                ans += f[i].area();

            printf("%.3f\n", ans);
            return 0;
        }
     ```

## 参考资料与注释

[^3d-basics-1][3D 空间基础概念之一：点、向量（矢量）和齐次坐标](https://www.cnblogs.com/CodeBlove/articles/1319563.html)
[^3d-v] [三维凸包学习小记](https://www.cnblogs.com/xzyxzy/p/10225804.html)
