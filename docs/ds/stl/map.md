### ```map``` 是啥鬼？

当你在写程序的时候，可能需要存储一些信息，例如存储学生姓名对应的分数，例如：```ddjxd 0```，```Ir1d 100```，```siyuan 100```，```yyfcpp 100```。
但是由于数组下标只能为非负整数，所以无法用姓名来存储，这个时候最简单的办法就是使用$STL$的$map$了！

```map``` 可任意类型为下标，下面是 ```map``` 的模型：
```
```map <类型名,类型名> 你想给map起的名字```
```
其中两个类型名第一个是数组的下标（索引），第二个是对应的元素。例如上面的例子，我们可以这样的存储：
```
map <string,int> mp
```
是不是感觉很神奇？

### ```map```  具体怎么使用？

- ```map``` 添加元素

1.直接存，例如```mp["ddjxd"]=0```
2.通过插入，例如```mp.insert(pair<string,int>,"siyuan",100));```

- ```map``` 查找删除元素

1.在你知道查找元素是啥的时候直接来就可以了，例如：```int grade=mp["ddjxd"]```
2.如果你知道了元素的下标，但是想知道这个元素是否已经存在```map```中，可以使用```find```函数。
格式：```if(mp.find()==mp.end())```，意思是如果返回的是```map```的末尾，因为```map```如果没有查找到元素，迭代器会返回末尾。
3.如果你想知道map里全部的元素，那么就要使用迭代器了，如果你还不会，请查阅之前文章中的迭代器。
```
for(iter=mp.begin();iter!=mp.end();iter++) {
        cout<<iter->first<<" "<<iter->second<<endl;
```
其中，```iter->first``` 是指的索引，例如 ```ddjxd```，而 ```iter->second``` 是下标。

当然，如果你想删除 ```ddjxd``` 这个元素，那么就可以在循环里加入：
```
if(i->first=="ddjxd") mp.erase(i);
```

- 其他

我们刚才介绍了最常用的，下面是全部的：

```

     begin()         返回指向map头部的迭代器

     clear(）        删除所有元素

     count()         返回指定元素出现的次数

     empty()         如果map为空则返回true

     end()           返回指向map末尾的迭代器

     equal_range()   返回特殊条目的迭代器对

     erase()         删除一个元素

     find()          查找一个元素

     get_allocator() 返回map的配置器

     insert()        插入元素

     key_comp()      返回比较元素key的函数

     lower_bound()   返回键值>=给定元素的第一个位置

     max_size()      返回可以容纳的最大元素个数

     rbegin()        返回一个指向map尾部的逆向迭代器

     rend()          返回一个指向map头部的逆向迭代器

     size()          返回map中元素的个数

     swap()           交换两个map

     upper_bound()    返回键值>给定元素的第一个位置

     value_comp()     返回比较元素value的函数
```

### ```map``` 常数靠得住吗？

一般情况下是可以的。无论查询，插入，删除的复杂度都是$O(logN)$，遍历是$O(N)$。

不过有的时候不会满足啊！我只想查询元素，插入元素，但是时间不够咋办？请往下看！

### 更快：基于 ```Hash``` 实现的 ```map```！

这个```map```的名字就是```unordered_map```了，它的查询，插入，删除的复杂度几乎是$O(1)$级别（不过最坏会达到O(N)$）的！

不过它的遍历速度会很慢，慢到至少$O(N)$。
