author: frank-xjh, qiqistyle

本页面将简要介绍枚举算法。

## 简介

枚举（英语：Enumerate）是基于已有知识来猜测答案的一种问题求解策略。

枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。

## 要点

### 给出解空间

建立简洁的数学模型。

枚举的时候要想清楚：可能的情况是什么？要枚举哪些要素？

### 减少枚举的空间

枚举的范围是什么？是所有的内容都需要枚举吗？

在用枚举法解决问题的时候，一定要想清楚这两件事，否则会带来不必要的时间开销。

### 选择合适的枚举顺序

根据题目判断。比如例题中要求的是最大的符合条件的素数，那自然是从大到小枚举比较合适。

## 例题

以下是一个使用枚举解题与优化枚举范围的例子。

!!! 例题
    一个数组中的数互不相同，求其中和为 $0$ 的数对的个数

??? note "解题思路"
    枚举两个数的代码很容易就可以写出来。
    
    ```cpp
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j)
        if (a[i] + a[j] == 0) ++ans;
    ```
    
    来看看枚举的范围如何优化。原问题的答案由两部分构成：两个数相等的情况和不相等的情况。相等的情况只需要枚举每一个数判断一下是否合法。至于不相等的情况，由于题中没要求数对是有序的，答案就是有序的情况的两倍（考虑如果 `(a, b)` 是答案，那么 `(b, a)` 也是答案）。对于这种情况，只需统计人为要求有顺序之后的答案，最后再乘上 $2$ 就好了。时间复杂度分析第一个循环执行 $n$ 次，每执行一次第一层循环第二层循环需要执行 $n$ 次故时间复杂度为 $O(n^2)$, 空间复杂度由于数组 $a$ 为输入数组则变量 ans 为用户定义变量为常量故空间复杂的为 $O(1)$.
    
    不妨要求第一个数要出现在靠前的位置。代码如下：
    
    ```cpp
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < i; ++j)
        if (a[i] + a[j] == 0) ++ans;
    ```
    
    不难发现这里已经减少了 $j$ 的枚举范围，减少了这段代码的时间开销。当 $i=1$ 时下一层循环 $if$ 语句执行 1 次，$i=2$ 时下一层循环 $if$ 语句执行 2 次，到 i=n 是 if 语句执行 n 次，利用求和公式 $1+2+\cdots+n= (n+1)*n/2$ 故时间复杂度为 $O(n^2)$, 空间复杂度还是为 $O(1)$.
    
    然而这并不是最优的结果（这里指的是时间复杂度不是最优）。
    
    两个数是否都一定要枚举出来呢？枚举其中一个数之后，题目的条件已经确定了其他的要素（另一个数），如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间了。
    
    ```cpp
    // 创建一个unordered_map的hash表
    unordered_map<int, int> mp;
    //计算每个a[i]的每个值出现在a数组的次数
    for (int i = 0; i < n; ++i) mp[a[i]]++;
    for (int i = 0; i < n; ++i) {
      //判断-a[i]值是否存在a数组中，如果存在mp[-a[i]]的值表示-a[i]在数组a出现的次数
      if (mp.count(-a[i])) ans += mp[-a[i]];
    }
    ```
    
    算法的时间复杂度分析 $unordered\_map$ 的底层实现是个类似于链表查询效率类似于数组每次查询的时间复杂度为 $O(1)$, 这个算法中只要遍历 a 数组 2 遍就可以求出最终结果，没有循环嵌套所以实现的时间复杂度为 $O(n)$, 空间复杂度在 数组 $a$ 的数互不相同则 $unordered\_map$ 的空间用了 $n$ 个 故空间复杂度为 $O(n)$, 在这个题目中实现了时间复杂度最优。

## 习题

- [2811: 熄灯问题 - OpenJudge](http://bailian.openjudge.cn/practice/2811/)
