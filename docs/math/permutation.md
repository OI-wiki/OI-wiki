置换和排列是各类问题中都很常见的概念。

??? info "本文讨论的不是排列数"
    本文讨论的主题是全排列，而不是排列组合中的排列数。排列数的相关内容应当参考 [排列组合](./combinatorics/combination.md)。

## 定义

一个集合 $X$ 到自身的双射（即一一对应）$\sigma$ 称为 $X$ 的一个 **置换**（permutation），或称 **（全）排列**。

本文中如果不加说明，总是讨论有限的集合。

设集合 $X$ 的大小是 $n$，那么，$X$ 上的全体置换的数目就是 $n!$。特别地，$0!=1$，即空集合上有且只有一个置换，也就是空置换。

## 表示

置换有多种表示方法。这里，以如下置换为例，讨论不同的置换表示方法。

$$
\sigma(1) = 2,\
\sigma(2) = 6,\
\sigma(3) = 5,\
\sigma(4) = 4,\
\sigma(5) = 3,\
\sigma(6) = 1.
$$

### 双行记号

集合 $X=\{x_1,x_2,\cdots,x_n\}$ 上的置换可以表示为

$$
\sigma=\begin{pmatrix}x_1&x_2&\cdots&x_n\\
x_{p_1}&x_{p_2}&\cdots&x_{p_n}
\end{pmatrix}.
$$

它表示置换 $\sigma$ 将元素 $x_i$ 映射到 $x_{p_i}$。这里，当然需要 $X=\{x_{p_1},x_{p_2},\cdots,x_{p_n}\}$。置换的双行记号表示中，首行的元素出现顺序并不重要，重要的是两行之间的对应关系。

比如说，前文的例子可以按照双行记号写作

$$
\sigma=
\begin{pmatrix}
1 & 2 & 3 & 4 & 5 & 6 \\
2 & 6 & 5 & 4 & 3 & 1
\end{pmatrix},
$$

当然，也可以写作

$$
\sigma=
\begin{pmatrix}
6 & 5 & 4 & 3 & 2 & 1 \\
1 & 3 & 4 & 5 & 6 & 2
\end{pmatrix}.
$$

### 单行记号

很多时候，集合 $X$ 上有自然的顺序。此时，不妨设大小为 $n$ 的集合在自然顺序下可以写做 $X=\{1,2,\cdots,n\}$。在双行记号中默认首行按照自然的顺序书写，那么，置换可以表示为

$$
\sigma=\sigma(1)\sigma(2)\cdots\sigma(n).
$$

这更像自然语言中排列的概念。所以，有时候排列会用来称呼这个有序组。

前文的例子利用单行记号可以写作

$$
\sigma=265431.
$$

这种单行的记号，常用来比较不同排列的大小。因为每个单行记号就是一个字符串，排列的顺序就是这个字符串上的 [字典序](../string/basic.md#字典序)。在 C++ 的 STL 库 `<algorithm>` 中可以使用 `prev_permutation` 和 `next_permutation` 分别找到当前排列按照字典序的上一个和下一个排列。

### 轮换表示

置换还有一种更为紧凑的表达方式，称为置换的轮换表示。它将置换表示为一系列不相交的轮换的乘积。下面描述将给定置换写成轮换表示的步骤。

给定一个置换 $\sigma$，可以通过如下步骤写成轮换表示：

1.  如果 $X$ 中还有未曾写下的元素，就写下一个左括号，并写下任意一个这样的元素；
2.  当前一个写下的元素是 $x$ 时，
    -   如果 $\sigma(x)$ 已经在前面写下过，就写上右括号，并返回步骤 1；
    -   如果 $\sigma(x)$ 还没有写下过，就写下 $\sigma(x)$，并继续步骤 2；
3.  直到 $X$ 的所有元素都已经写下，结束。

每一对括号中，都是一个轮换。括号中的元素个数，称为对应轮换的长度。实践中，常常省略掉长度为一的轮换。

前文的例子利用轮换表示可以写作

$$
\sigma=(126)(35)(4)=(126)(35).
$$

恒等变换中所有的轮换长度都是一，常常记作 $(1)$ 而不是全部省略。

## 复合

置换的复合就是映射的复合。置换的复合也常常称作置换的乘法。

给定两个置换

$\sigma=\begin{pmatrix}x_1&x_2&\cdots&x_n\\ x_{p_1}&x_{p_2}&\cdots&x_{p_n}\end{pmatrix},\ \pi=\begin{pmatrix}x_{p_1}&x_{p_2}&\cdots&x_{p_n}\\ x_{q_1}&x_{q_2}&\cdots&x_{q_n}\end{pmatrix},$

那么，它们的乘积 $\pi\circ\sigma$ 的值为

$$
\pi\circ\sigma=\begin{pmatrix}x_1&x_2&\cdots&x_n\\
x_{q_1}&x_{q_2}&\cdots&x_{q_n}\end{pmatrix}.
$$

简单来说就是先经过 $\sigma$ 的映射，再经过 $\pi$ 的映射。注意在上面的双行记号中，内层映射 $\sigma$ 的第二行的顺序和外层映射 $\pi$ 的第一行的顺序一致。

因为置换 $\sigma$ 和 $\pi$ 本质是两个映射，所以 $(\pi\circ\sigma)(x)=\pi(\sigma(x))$。置换的复合的运算顺序是自右向左的。

### 逆置换

因为置换是双射，所以置换总有相应的逆置换。

给定置换

$$
\sigma=\begin{pmatrix}x_1&x_2&\cdots&x_n\\ x_{p_1}&x_{p_2}&\cdots&x_{p_n}\end{pmatrix},
$$

它的逆置换就是

$$
\sigma^{-1}=\begin{pmatrix}x_{p_1}&x_{p_2}&\cdots&x_{p_n}\\x_1&x_2&\cdots&x_n\end{pmatrix}.
$$

在轮换表示中，只要对每个轮换取逆，就能得到原来的置换的逆；而对每个轮换取逆，只要把元素的书写顺序倒过来就可以了。比如说，上文中的例子 $\sigma$ 的逆置换的轮换表示是

$$
\sigma^{-1} = (621)(53) = (162)(35).
$$

## 逆序数

考虑集合 $X$ 有自然顺序的情形。此时，一个置换也常称作是一个排列。

在一个置换中，如果某一个较大的数排在某一个较小的数前面，就说这两个数构成一个 **逆序**（inversion）或反序。

在一个置换里出现的逆序的总个数，叫做这个置换的 **逆序数**。

### 奇偶性

一个置换的逆序数可能是偶数也可能是奇数。一个置换的逆序数的奇偶性也称作置换的 **奇偶性**（parity）。

有偶数个逆序的置换叫做一个偶置换，有奇数个逆序的置换叫做一个奇置换。当 $n\ge2$ 时，大小为 $n$ 的奇置换和偶置换的数目相同。

根据置换的奇偶性，还可以定义置换的符号 $\mathrm{sgn}~\sigma$。偶置换的符号定义为 $+1$，奇置换的符号定义为 $-1$。

置换的乘积的符号，等于它们的符号的乘积，即

$$
\mathrm{sgn}~(\pi\circ\sigma)=\mathrm{sgn}
~\pi\cdot\mathrm{sgn}~\sigma.
$$

也就是说，两个奇偶性相同的置换的复合是偶置换，两个奇偶性不同的置换的复合是奇置换。

置换的符号应用在 [行列式的 Leibniz 展开](../math/linear-algebra/determinant.md#全排列方法定义) 中。

### 逆序数的计算方法

逆序数的编程计算方法，可以使用 [归并排序](../basic/merge-sort.md#逆序对) 或 [树状数组](../ds/fenwick.md#全局逆序对全局二维偏序)，时间复杂度均为 $O(n\log n)$。

??? example "参考实现"
    === "归并排序"
        ```cpp
        --8<-- "docs/math/code/permutation/inversion_2.cpp"
        ```
    
    === "树状数组"
        ```cpp
        --8<-- "docs/math/code/permutation/inversion_1.cpp"
        ```

## 轮换

**轮换**（cycle）本身是特殊的置换。轮换的特性是，从轮换中的任何一点 $x$ 出发，都能通过反复应用置换 $\sigma$ 的方式得到轮换中的另一点 $y$。长度为 $k$ 的轮换也称作 **$k$‑轮换**（$k$-cycle）。反复应用 $k$‑轮换 $k$ 次，将得到恒等变换，即每个元素都回到了最开始的位置。

置换的轮换表示可以看作将置换写成这些特殊置换（即轮换）的乘积。对于每个置换，它分解成轮换乘积的方式在不计顺序后都是唯一的。轮换可以看作是构成置换的基本单元。

置换的轮换分解有着清晰的几何意义。如果将集合 $S$ 上的置换中的每个有序对 $(x,\sigma(x))$ 都看成以 $S$ 为顶点的有向图的边，那么这些轮换就是这个图上面的环路。如果置换 $\sigma$ 能够写作 $m$ 个置换，就意味着对应的有向图中共计有 $m$ 个环路（包括自环）。这些环路自然互不相交。

### 不动点

$1$‑轮换就是置换的 **不动点**（fixed point）。对于集合 $X$ 上的置换 $\sigma$，通常用 $X^\sigma$ 表示 $\sigma$ 的不动点集合，即 $X^\sigma=\{x\in X:\sigma(x)=x\}$。

### 对换

$2$‑轮换也称作 **对换**（transposition）。也就是说，对换就是只交换了一对元素位置的置换。它的轮换表示是 $(x_ix_j)$，表示它交换了 $x_i$ 和 $x_j$ 的位置。

任何置换都可以写作一系列对换的乘积。这相当于说，任何顺序的排列都可以通过一系列交换两个元素的操作恢复成指定的正序排列。这正是基于交换的排序算法在做的事情。

更进一步，冒泡算法的正确性其实说明，任何置换都可以写作一系列相邻对换的乘积。这里的 **相邻对换**（adjacent transposition）指的是只交换相邻元素的对换。置换的逆序数是它恢复成正序序列需要的最少次数。

但是，这样的分解并不是唯一的。因为每次对换都改变了排列的奇偶性，所以置换分解成一系列对换时，需要的对换的数目的奇偶性是固定的。这是另一种常见的定义置换的奇偶性和符号的方式。

### 置换的型

将 $n$ 个元素的置换做轮换分解，置换的 **型**（cycle type）就是分解中轮换长度的可重集合。这些轮换的长度构成了一个置换长度 $n$ 的整数分划。如果得到的分解中长度为 $k$ 的轮换共计 $\alpha_k$ 个，那么置换的型常记作

$$
1^{\alpha_1}2^{\alpha_2}\cdots n^{\alpha_n},
$$

且这些系数满足 $\sum_{k=1}^nk\alpha_k=n$。

给定置换的型，不同的置换的数目为

$$
\frac{n!}{1^{\alpha_1}2^{\alpha_2}\cdots n^{\alpha_n}\alpha_1!\alpha_2!\cdots\alpha_n!}.
$$

??? note "分析"
    这是因为，给定任何 $1\sim n$ 的排列，都可以按照置换的型分割成相应的轮换分解。但是，长度相同的轮换之间的顺序并不影响置换，所以总数需要除以 $\prod_k\alpha_k!$。另外，同一轮换内部实际是圆排列，起点的选取也不影响置换，所以需要除以 $\prod_kk^{\alpha_k}$。这就得到上式。

从置换的型，可以方便地确定置换的阶和奇偶性等性质。置换的 **阶**（order）是指最小的次数 $a$，使得重复该置换 $a$ 次后，所有元素都回到了原位。因为 $k$‑轮换的阶是 $k$，所以置换 $\sigma$ 的阶就是

$$
\mathrm{lcm}\{k:\alpha_k>0\}.
$$

同样地，因为 $k$‑轮换的奇偶性与 $k$ 的奇偶性相反，所以置换 $\sigma$ 的奇偶性就是

$$
\sum_k(k-1)\alpha_k=\sum_{k}k\alpha_k-\sum_{k}\alpha_k=n-c(\sigma)
$$

的奇偶性。这里，$c(\sigma)$ 正是轮换的个数（包括 $1$‑轮换，即不动点）。

置换的型在 [Pólya 计数](./combinatorics/polya.md) 中有重要作用。

## 参考资料与注释

-   [Permutation - Wikipedia](https://en.wikipedia.org/wiki/Permutation)
