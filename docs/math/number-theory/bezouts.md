
裴蜀定理，又称贝祖定理（Bézout's lemma）。是一个关于最大公约数的定理。

其内容是：

设 $a,b$ 是不全为零的整数，则存在整数 $x,y$, 使得 $ax+by=\gcd(a,b)$.

## 证明

1. 若任何一个等于 $0$, 则 $\gcd(a,b)=a$. 这时定理显然成立。

2.  若 $a,b$ 不等于 $0$.

    由于 $\gcd(a,b)=\gcd(a,-b)$,

    不妨设 $a,b$ 都大于 $0$，$a\geq b,\gcd(a,b)=d$.

    对 $ax+by=d$, 两边同时除以 $d$, 可得 $a_1x+b_1y=1$, 其中 $(a_1,b_1)=1$.

    转证 $a_1x+b_1y=1$.

    我们先回顾一下辗转相除法是怎么做的，由 $\gcd(a, b) \rightarrow \gcd(b,a\mod b) \rightarrow ...$ 我们把模出来的数据叫做 $r$ 于是，有

    $$
    \gcd(a_1,b_1)=\gcd(b_1,r_1)=\gcd(r_1,r_2)=\cdots=(r_{n-1},r_n)=1
    $$

    把辗转相除法中的运算展开，做成带余数的除法，得

    $$
    \begin{aligned}a_1 &= q_1b+r_1 &(0\leq r_1<b_1) \\ b_1 &= q_2r_1+r_2 &(0\leq r_2<r_1) \\ r_1 &= q_3r_2+r_3 &(0\leq r_3<r_2) \\ &\cdots \\ r_{n-3} &= q_{n-1}r_{n-2}+r_{n-1} \\ r_{n-2} &= q_nr_{n-1}+r_n \\ r_{n-1} &= q_{n+1}r_n\end{aligned}
    $$

    不妨令辗转相除法在除到互质的时候退出则 $r_n=1$ 所以有（$q$ 被换成了 $x$，为了符合最终形式）

    $$
    r_{n-2}=x_nr_{n-1}+1
    $$

    即

    $$
    1=r_{n-2}-x_nr_{n-1}
    $$

    由倒数第三个式子 $r_{n-1}=r_{n-3}-x_{n-1}r_{n-2}$ 代入上式，得

    $$
    1=(1+x_nx_{n-1})r_{n-2}-x_nr_{n-3}
    $$

    然后用同样的办法用它上面的等式逐个地消去 $r_{n-2},\cdots,r_1$,

    可证得 $1=a_1x+b_1y$.
    这样等于是一般式中 $d=1$ 的情况。

## 应用

???+ note "Codeforces Round #290 (Div. 2) D. Fox And Jumping"
    给出 $n$ 张卡片，分别有 $l_i$ 和 $c_i$。在一条无限长的纸带上，你可以选择花 $c_i$ 的钱来购买卡片 $i$，从此以后可以向左或向右跳 $l_i$ 个单位。问你至少花多少元钱才能够跳到纸带上全部位置。若不行，输出 $-1$。

分析该问题，先考虑两个数的情况，发现想要跳到每一个格子上，必须使得这些数通过数次相加或相减得出的绝对值为 $1$，进而想到了裴蜀定理。

可以推出：如果 $a$ 与 $b$ 互质，那么一定存在两个整数 $x$ 与 $y$，使得 $ax+by=1$.

由此得出了若选择的卡牌的数通过数次相加或相减得出的绝对值为 $1$，那么这些数一定互质，此时可以考虑动态规划求解。

不过可以转移思想，因为这些数互质，即为 $0$ 号节点开始，每走一步求 $\gcd$（节点号，下一个节点），同时记录代价，就成为了从 $0$ 通过不断 $\gcd$ 最后变为 $1$ 的最小代价。

由于：互质即为最大公因数为 $1$，$\gcd(0,x)=x$ 这两个定理，可以证明该算法的正确。选择优先队列优化 Dijkstra 求解。

不过还有个问题，即为需要记录是否已经买过一个卡片，开数组标记由于数据范围达到 $10^9$ 会超出内存限制，可以想到使用 `unordered_map`（比普通的 `map` 更快地访问各个元素，迭代效率较低，详见 [STL-map](../lang/csl/associative-container.md)）

## 进一步结论

设自然数a、b和整数n。a与b互素。考察不定方程：

$$ax+by=n$$

其中x和y为自然数。如果方程有解，称n可以被a、b表示。

记C=ab-a-b。由a与b互素，C必然为奇数。则有结论：

**对任意的整数n，n与C-n中有且仅有一个可以被表示。**

即：可表示的数与不可表示的数在区间[0,C]对称（关于C的一半对称）。0可被表示，C不可被表示；负数不可被表示，大于C的数可被表示。

### 证明

由于a、b互素，因此原方程有整数解。设解为：

$$\begin{cases}x=x_0+bt\\y=y_0-at\end{cases}$$

其中t为整数。取适当的t，使得y位于0到a-1之间。这只需在y0上加上或减去若干个a，即可得到这样的t。

第一步：证明大于C的数都可以被表示。当n大于C时：

$$ax=n-by>ab-a-b-by\geqslant ab-a-b-b(a-1)=-a$$

于是x也是非负整数。

第二步：证明C不可被表示，进而n与C-n不可能都被表示。

反证法。若ax+by=ab-a-b有非负整数解x、y，则：

$$ab=a(x+1)+b(y+1)$$

由于a与b互素，所以a整除y+1，b整除x+1，a不超过y+1，b不超过x+1。于是有：

$$ab=a(x+1)+b(y+1)\geqslant ab+ab=2ab$$

矛盾！第二步证完。

第三步：证明如果n不可被表示，则C-n可被表示。

由上可知，若n不可被表示，由于上述方程中已规定y在0到a-1之间，则x为负。所以：

$$ab-a-b-ax-by=a(-x-1)+b(a-1-y)$$

显然-x-1和a-1-y均非负，于是C-n可被表示。

### 几何意义

重新观察方程ax+by=n，将它看成一条直线。直线与两坐标轴在第一象限围成三角形。

当n小于ab的时候，这个直线在第一象限，至多只能通过一个整点。

根据上述讨论：当n可以被表示的时候，直线恰好经过一个整点；当n不可以被表示的时候，直线不经过整点（在第一象限）。

这结论也可以理解为：作三角形(0,0)(b,0)(0,a)。随着n从0不断增加，直线向右上方平移，整点会一个一个地通过直线，直到最后才撞上两个整点。

因此，小于等于n的能被表示的非负整数的数量，恰好就是直线ax+by=n（含）与两坐标轴（含）在第一象限围成三角形覆盖的整点个数。

### 另一种解释

考虑模b意义下每个剩余系中最小能被表示的值是多少——大于他们的可以通过增加若干个b得到。

观察原方程，a的若干倍数0, a, · · · , (b − 1)a 在mod b 意义下互不相同。这些数恰好是这些最小值。那么当n<ab时，小于等于n的能被表示的非负整数的数量是：

$$ \sum\limits_{i=0}^{\left[\frac{n}{a}\right]}\left[\frac{n − ia}{b}\right]$$

这是一个非常经典的直线下整点问题，恰好是这条直线：

$$y=-\frac{a}{b}x+\frac{n}{b}$$

即ax+by=n。

使用类欧几里得算法可以在O(log max(a,b)) 的时间内求解。因此我们得到了计算小于等于n的能被表示的非负整数的数量的工具。

### 题目

[P3951 NOIP2017 提高组 小凯的疑惑 / 蓝桥杯 2013 省 买不到的数目](https://www.luogu.com.cn/problem/P3951)